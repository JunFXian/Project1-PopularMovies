/**
 * Created by Jun Xian for Udacity Android Developer Nanodegree project 1
 * Date: May 22, 2017
 * Reference:
 *      https://github.com/udacity/android-custom-arrayadapter/tree/gridview
 *      https://stackoverflow.com/questions/4993026/using-setonitemclicklistener-for-items-in-listview
 *      https://github.com/udacity/ud851-Sunshine
 *      https://github.com/udacity/ud851-Exercises
 *      https://stackoverflow.com/questions/1560788/how-to-check-internet-access-on-android-inetaddress-never-times-out
 *      http://www.jameselsey.co.uk/blogs/techblog/extracting-out-your-asynctasks-into-separate-classes-makes-your-code-cleaner/
 *      https://stackoverflow.com/questions/15643907/multiple-loaders-in-same-activity
 */

package com.udacity.jun.popularmovies;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.net.ConnectivityManager;
import android.support.annotation.NonNull;
import android.support.v4.app.LoaderManager;
import android.support.v4.content.Loader;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.GridView;
import android.widget.AdapterView;
import android.view.View;
import android.widget.TextView;
import android.widget.Toast;

import com.udacity.jun.popularmovies.async.ContentProviderAsyncTaskLoader;
import com.udacity.jun.popularmovies.async.ContentProviderCheckFavoriteAsyncTaskLoader;
import com.udacity.jun.popularmovies.async.MovieDetailAsyncTaskLoader;
import com.udacity.jun.popularmovies.adapters.GridAdapter;
import com.udacity.jun.popularmovies.data.FavoriteMovieContract;
import com.udacity.jun.popularmovies.models.MovieDetail;
import com.udacity.jun.popularmovies.models.ListWrapper;
import com.udacity.jun.popularmovies.models.MoviePoster;
import com.udacity.jun.popularmovies.utilities.NetworkUtils;

import java.util.ArrayList;
import java.util.List;

public class MainActivity extends AppCompatActivity{
//    //Constants for logging
//    private static final String TAG = MainActivity.class.getSimpleName();
    // Constant for referring to a unique AsyncTaskLoader for fetching movie details
    private static final int ASYNCTASK_LOADER_ID = 0;
    // Constant for referring to a unique CursorLoader for fetching data from content provider
    private static final int CURSOR_LOADER_ID = 1;
    private static final int CURSOR_CHECK_FAVORITE_LOADER_ID = 2;

    private GridView movieGridView;
    // for store the grid position
    private int visibleGridIndex = 0;
    private static String currentSorting;
    private final ListWrapper<MovieDetail> movieDetailsList = new ListWrapper<>();
    private final ListWrapper<MovieDetail> favoriteMovieDetailsList = new ListWrapper<>();

    private final LoaderManager.LoaderCallbacks<List<MovieDetail>> asyncTaskLoaderListener
            = new LoaderManager.LoaderCallbacks<List<MovieDetail>>() {
        //Override the required methods in LoaderCallbacks
        @Override
        public Loader<List<MovieDetail>> onCreateLoader(int id, @NonNull final Bundle loaderArgs) {
            String sortMethod = "";
            if (loaderArgs.size() > 0) {
                sortMethod = loaderArgs.getString(getString(R.string.loader_bundle_key_sort_method));
            }
            return new MovieDetailAsyncTaskLoader(MainActivity.this, sortMethod);
        }

        /**
         * Called when a previously created loader has finished its load.
         * @param loader The Loader that has finished.
         * @param allMovieListResult The data generated by the Loader.
         */
        @Override
        public void onLoadFinished(Loader<List<MovieDetail>> loader, List<MovieDetail> allMovieListResult) {
            //check if the passing result has content or not
            if (allMovieListResult != null) {
                movieDetailsList.items = allMovieListResult;
                List<MoviePoster> posterList = getMoviePosterList(movieDetailsList);

                // construct custom array adapter (grid adapter) in order to create the adapter view (grid view)
                GridAdapter gridAdapter = new GridAdapter(MainActivity.this, posterList);
                // attach adapter to the GridView
                movieGridView.setAdapter(gridAdapter);
                movieGridView.setSelection(visibleGridIndex);
            } else {
                Toast.makeText(MainActivity.this, getString(R.string.toast_msg_no_result), Toast.LENGTH_SHORT).show();
            }
        }

        /**
         * Called when a previously created loader is being reset, and thus
         * making its data unavailable.
         * onLoaderReset removes any references this activity had to the loader's data.
         * @param loader The Loader that is being reset.
         */
        @Override
        public void onLoaderReset(Loader<List<MovieDetail>> loader) {
        }
    };

    private final LoaderManager.LoaderCallbacks<Cursor> cursorLoaderListener
            = new LoaderManager.LoaderCallbacks<Cursor>() {
        /**
         * Instantiates and returns a new AsyncTaskLoader with the given ID.
         * This loader will return task data as a Cursor or null if an error occurs.
         * Implements the required callbacks to take care of loading data at all stages of loading.
         */
        @Override
        public Loader<Cursor> onCreateLoader(int id, @NonNull final Bundle loaderArgs) {
            return new ContentProviderAsyncTaskLoader(MainActivity.this);
        }

       /**
        * Called when a previously created loader has finished its load.
        *
        * @param loader The Loader that has finished.
        * @param resultCursor The data generated by the Loader.
        */
        @Override
        public void onLoadFinished(Loader<Cursor> loader, Cursor resultCursor) {
            String[] movieArray = new String[6];
            List<MovieDetail> favoriteList = new ArrayList<>();
            GridAdapter gridAdapter;
            try {
                if (resultCursor != null && resultCursor.moveToFirst()) {
                    do {
                        movieArray[0] = resultCursor.getString(resultCursor.getColumnIndex(FavoriteMovieContract.FavoriteMovieEntry.COLUMN_MOVIE_ID));
                        movieArray[1] = resultCursor.getString(resultCursor.getColumnIndex(FavoriteMovieContract.FavoriteMovieEntry.COLUMN_POSTERURI));
                        movieArray[2] = resultCursor.getString(resultCursor.getColumnIndex(FavoriteMovieContract.FavoriteMovieEntry.COLUMN_TITLE));
                        movieArray[3] = resultCursor.getString(resultCursor.getColumnIndex(FavoriteMovieContract.FavoriteMovieEntry.COLUMN_OVERVIEW));
                        movieArray[4] = resultCursor.getString(resultCursor.getColumnIndex(FavoriteMovieContract.FavoriteMovieEntry.COLUMN_RATE));
                        movieArray[5] = resultCursor.getString(resultCursor.getColumnIndex(FavoriteMovieContract.FavoriteMovieEntry.COLUMN_DATE));
                        MovieDetail singleMovie = new MovieDetail(movieArray);
                        favoriteList.add(singleMovie);
                    } while (resultCursor.moveToNext());
                    favoriteMovieDetailsList.items = favoriteList;

                    List<MoviePoster> posterList = getMoviePosterList(favoriteMovieDetailsList);
                    // construct custom array adapter (grid adapter) in order to create the adapter view (grid view)
                    gridAdapter = new GridAdapter(MainActivity.this, posterList);
                    // attach adapter to the GridView
                    movieGridView.setAdapter(gridAdapter);
                    movieGridView.setBackgroundColor(getResources().getColor(R.color.black));
                    movieGridView.setSelection(visibleGridIndex);
                } else {
                    movieGridView.setAdapter(null);
                    movieGridView.setBackgroundColor(getResources().getColor(R.color.black));
                    Toast.makeText(MainActivity.this, getString(R.string.toast_msg_no_favorite), Toast.LENGTH_SHORT).show();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

       /**
        * Called when a previously created loader is being reset, and thus
        * making its data unavailable.
        * onLoaderReset removes any references this activity had to the loader's data.
        *
        * @param loader The Loader that is being reset.
        */
        @Override
        public void onLoaderReset(Loader<Cursor> loader) {
        }
    };

    private final LoaderManager.LoaderCallbacks<Cursor> cursorCheckFavoriteLoaderListener
            = new LoaderManager.LoaderCallbacks<Cursor>() {
        private String movieDetailArray[] = new String[6];
        @Override
        public Loader<Cursor> onCreateLoader(int id, @NonNull final Bundle loaderArgs) {
            String movieId = "";
            if (loaderArgs.size() > 0) {
                movieDetailArray = loaderArgs.getStringArray(getString(R.string.loader_bundle_key_movie_detail));
                if (movieDetailArray != null) {
                    movieId = movieDetailArray[0];
                }
            }
            return new ContentProviderCheckFavoriteAsyncTaskLoader(MainActivity.this, movieId);
        }

        @Override
        public void onLoadFinished(Loader<Cursor> loader, Cursor resultCursor) {
            String isMovieFavored;
            try {
                if (resultCursor != null && resultCursor.moveToFirst()) {
                    isMovieFavored = getString(R.string.is_true);
                } else {
                    isMovieFavored = getString(R.string.is_false);
                }
                // Start the child activity
                Context context = MainActivity.this;
                Class destinationClass = DetailActivity.class;
                Intent intentToStartDetailActivity = new Intent(context, destinationClass);
                intentToStartDetailActivity.putExtra(Intent.EXTRA_TEXT, movieDetailArray);
                intentToStartDetailActivity.putExtra(getString(R.string.intent_key_is_favorite), isMovieFavored);
                startActivity(intentToStartDetailActivity);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        @Override
        public void onLoaderReset(Loader<Cursor> loader) {
        }
    };

    private SharedPreferences mSharedPreferences;

    // create a main layout
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        setTitle(getString(R.string.app_sorting_popularity));

        // associate grid layout to the GridView
        movieGridView = (GridView) findViewById(R.id.main_grid);

        // On first launching the app, use sharedpreferences to retrieve the sorting state
        // name of the sharedpreferences file
        final String mPref = getString(R.string.sorting_shared_preference);

        mSharedPreferences = getSharedPreferences(mPref, MainActivity.MODE_PRIVATE);
        /*
         * The default value when the app first-time launches is sort_by_popularity, the value will change upon user interaction
         * and will store in the sharedpreference, as long as the app does not uninstalled, the sharedpreferences will not get cleared
         */
        currentSorting = mSharedPreferences.getString(getString(R.string.pref_sorting_key), getString(R.string.sort_by_popularity));

        /*
         * Ensure a loader is initialized and active. If the loader doesn't already exist, one is
         * created, otherwise the last created loader is re-used.
         */
//        getSupportLoaderManager().initLoader(ASYNCTASK_LOADER_ID, null, asyncTaskLoaderListener);
//        getSupportLoaderManager().initLoader(CURSOR_LOADER_ID, null, cursorLoaderListener);
//        getSupportLoaderManager().initLoader(CURSOR_CHECK_FAVORITE_LOADER_ID, null, cursorCheckFavoriteLoaderListener);
    }

    // Override onResume to handle the back up button when in top rated movies detail view
    @Override
    public void onResume() {
        super.onResume();  // Always call the superclass method first
        // On first launching the app, network request to retrieve most popular movies
        if (!currentSorting.equals(getString(R.string.sort_by_favorite))) {
            if (currentSorting.equals(getString(R.string.sort_by_rated))){
                setTitle(getString(R.string.app_sorting_rate));
            } else {
                setTitle(getString(R.string.app_sorting_popularity));
            }
            fetchMoviesData(currentSorting);
        } else {
            LoaderManager cursorLoaderManager = getSupportLoaderManager();
            Loader<Cursor> cursorLoader = cursorLoaderManager.getLoader(CURSOR_LOADER_ID);
            if (cursorLoader == null) {
                cursorLoaderManager.initLoader(CURSOR_LOADER_ID, null, cursorLoaderListener);
            } else {
                cursorLoaderManager.restartLoader(CURSOR_LOADER_ID, null, cursorLoaderListener);
            }

            setTitle(getString(R.string.app_sorting_favorite));
            movieGridView.setOnItemClickListener(new MovieItemOnClick(favoriteMovieDetailsList));
        }
    }

    // Override onPause to handle the interrupt to the detail activity
    @Override
    public void onPause() {
        super.onPause();  // Always call the superclass method first
        visibleGridIndex = movieGridView.getFirstVisiblePosition();
    }

    // Save and restore some data when the whole lifecycle of activity runs again due to screen size, orientation change
    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putString(getString(R.string.bundle_key_sorting),currentSorting);
        outState.putInt(getString(R.string.bundle_key_position),visibleGridIndex);
    }
    @Override
    protected void onRestoreInstanceState(Bundle savedInstanceState) {
        super.onRestoreInstanceState(savedInstanceState);
        if (savedInstanceState != null) {
            currentSorting = savedInstanceState.getString(getString(R.string.bundle_key_sorting));
            visibleGridIndex = savedInstanceState.getInt(getString(R.string.bundle_key_position));
        }
    }

    /**
     * This method is to construct the url and use AsyncTask to execute the request
     * @param sortByMethod the sorting method of the data request
     */
    private void fetchMoviesData(String sortByMethod) {
        // check the device connectivity
        if (isOnline()){
            //create a loader thread for fetching movies data, and initialise it with the callback listener
            Bundle asyncBundle = new Bundle();
            asyncBundle.putString(getString(R.string.loader_bundle_key_sort_method), sortByMethod);
           /**
            * Now that we've created our bundle that we will pass to our Loader, we need to decide
            * if we should restart the loader (if the loader already existed) or if we need to
            * initialize the loader (if the loader did NOT already exist).
            */
            LoaderManager loaderManager = getSupportLoaderManager();
            Loader<ListWrapper<MovieDetail>> asyncTaskLoader = loaderManager.getLoader(ASYNCTASK_LOADER_ID);
            if (asyncTaskLoader == null) {
                loaderManager.initLoader(ASYNCTASK_LOADER_ID, asyncBundle, asyncTaskLoaderListener);
            } else {
                /**
                 * This method is called after this activity has been paused or restarted.
                 * Often, this is after new data has been inserted through an AddTaskActivity,
                 * so this restarts the loader to re-query the underlying data for any changes.
                 */
                // re-queries for all tasks
                loaderManager.restartLoader(ASYNCTASK_LOADER_ID, asyncBundle, asyncTaskLoaderListener);
            }

            // set onItemClickListener after the grid view is populated
            movieGridView.setOnItemClickListener(new MovieItemOnClick(movieDetailsList));
        } else {
            setContentView(R.layout.activity_no_internet);
            TextView noInternet = (TextView) findViewById(R.id.no_internet);
            noInternet.setText(getString(R.string.no_internet_connection));
        }
    }

    /**
     * This inner class is to handle the click event on the movie poster
     */
    public class MovieItemOnClick implements AdapterView.OnItemClickListener{
        private String[] movie = new String[6];
        private MovieDetail singleMovieDetail = null;
        private final ListWrapper<MovieDetail> listWrapper;

        public MovieItemOnClick(ListWrapper<MovieDetail> wrapper) {
            this.listWrapper = wrapper;
        }

        // After detect a click on the grid view, the app triggers next activity
        @Override
        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
            visibleGridIndex = position;
            singleMovieDetail = listWrapper.items.get(position);
            movie = singleMovieDetail.convertToStringArray();

            //check from the database to see if the selected movie is currently favored or not
            Bundle asyncCheckFavoriteBundle = new Bundle();
            asyncCheckFavoriteBundle.putStringArray(getString(R.string.loader_bundle_key_movie_detail), movie);
            LoaderManager cursorloaderCheckFavoriteManager = getSupportLoaderManager();
            Loader<Cursor> cursorCheckFavoriteLoader = cursorloaderCheckFavoriteManager.getLoader(CURSOR_CHECK_FAVORITE_LOADER_ID);
            if (cursorCheckFavoriteLoader == null) {
                cursorloaderCheckFavoriteManager.initLoader(CURSOR_CHECK_FAVORITE_LOADER_ID, asyncCheckFavoriteBundle, cursorCheckFavoriteLoaderListener);
            } else {
                cursorloaderCheckFavoriteManager.restartLoader(CURSOR_CHECK_FAVORITE_LOADER_ID, asyncCheckFavoriteBundle, cursorCheckFavoriteLoaderListener);
            }
        }
    }

    /**
     * This method is to check the device is currently online or not
     * @return a boolean to check if the device is connected
     */
    private boolean isOnline() {
        ConnectivityManager cm = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
        return cm.getActiveNetworkInfo() != null && cm.getActiveNetworkInfo().isConnectedOrConnecting();
    }

    /**
     * This method is to extract movie poster path from the movie details list
     * @param movieDetailsArrayList an array list of the MovieDetail type objects
     * @return Array of MoviePoster contains movie poster url and title
     */
    private List<MoviePoster> getMoviePosterList(ListWrapper<MovieDetail> movieDetailsArrayList){
        String posterPath;
        String imageUrl;
        List<MoviePoster> posterList = new ArrayList<>();
        for (int i=0; i < movieDetailsArrayList.items.size(); i++) {
            posterPath = movieDetailsArrayList.items.get(i).getPosterPath();
            //Poster size can be one of the following: "w92", "w154", "w185", "w342", "w500", "w780", or "original"
            imageUrl = NetworkUtils.posterURL(getString(R.string.image_base_url),
                    getString(R.string.poster_size), posterPath);
            MoviePoster poster = new MoviePoster();
            poster.setPosterUrl(imageUrl);
            poster.setPosterTitle(movieDetailsArrayList.items.get(i).getOriginalTitle());
            posterList.add(i, poster);
        }
        return posterList;
    }

    // create menu
    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.menu_main, menu);
        return true;
    }
    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        SharedPreferences.Editor mPreferencesEditor = mSharedPreferences.edit();

        int itemBeClickedId = item.getItemId();
        visibleGridIndex = 0;
        // if select sort_by_rate and currently is sorted by popularity,
        // then refresh and switch the sorting
        if (itemBeClickedId == R.id.action_sortbyrate && !currentSorting.equals(getString(R.string.sort_by_rated))) {
            fetchMoviesData(getString(R.string.sort_by_rated));
            // update the current sorting method
            currentSorting = getString(R.string.sort_by_rated);
            // store a new value to the sharedpreferences
            mPreferencesEditor.putString(getString(R.string.pref_sorting_key), currentSorting);
//            mPreferencesEditor.commit();
            mPreferencesEditor.apply();

            setTitle(getString(R.string.app_sorting_rate));
            Toast.makeText(this, getString(R.string.toast_msg_sort_by_rated), Toast.LENGTH_SHORT).show();
            return true;
        }
        // if select sort_by_popularity and currently is sorted by rate,
        // then refresh and switch the sorting
        if (itemBeClickedId == R.id.action_sortbypopularity && !currentSorting.equals(getString(R.string.sort_by_popularity))) {
            fetchMoviesData(getString(R.string.sort_by_popularity));
            // update the current sorting method
            currentSorting = getString(R.string.sort_by_popularity);
            // store a new value to the sharedpreferences
            mPreferencesEditor.putString(getString(R.string.pref_sorting_key), currentSorting);
//            mPreferencesEditor.commit();
            mPreferencesEditor.apply();

            setTitle(getString(R.string.app_sorting_popularity));
            Toast.makeText(this, getString(R.string.toast_msg_sort_by_popularity), Toast.LENGTH_SHORT).show();
            return true;
        }
        // click favorite to see the favorite movie list
        if (itemBeClickedId == R.id.action_sortbyfavorite && !currentSorting.equals(getString(R.string.sort_by_favorite))) {
            currentSorting = getString(R.string.sort_by_favorite);
            // store a new value to the sharedpreferences
            mPreferencesEditor.putString(getString(R.string.pref_sorting_key), currentSorting);
//            mPreferencesEditor.commit();
            mPreferencesEditor.apply();

            //Reset the main layout
            setContentView(R.layout.activity_main);
            movieGridView = (GridView) findViewById(R.id.main_grid);
            // query all movie in the favorite movie list
            LoaderManager cursorLoaderManager = getSupportLoaderManager();
            Loader<Cursor> cursorLoader = cursorLoaderManager.getLoader(CURSOR_LOADER_ID);
            if (cursorLoader == null) {
                cursorLoaderManager.initLoader(CURSOR_LOADER_ID, null, cursorLoaderListener);
            } else {
                cursorLoaderManager.restartLoader(CURSOR_LOADER_ID, null, cursorLoaderListener);
            }

            setTitle(getString(R.string.app_sorting_favorite));
            Toast.makeText(this, getString(R.string.toast_msg_sort_by_favorite), Toast.LENGTH_SHORT).show();
            // set onItemClickListener after the grid view is populated
            movieGridView.setOnItemClickListener(new MovieItemOnClick(favoriteMovieDetailsList));
            return true;
        }
        return super.onOptionsItemSelected(item);
    }
}

